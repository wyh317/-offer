# 面试题56：数组中数字出现的次数

## 题目一
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

    示例 1：
    输入：nums = [4,1,4,6]
    输出：[1,6] 或 [6,1]

    示例 2：
    输入：nums = [1,2,10,4,1,4,3,3]
    输出：[2,10] 或 [10,2]

## 方法

先考虑只有一个数字只出现依次的情况。在这种情况下，我们从头到尾异或数组中的每个数字，最终的结果刚好就是那个只出现一次的数字，因为任何一个数字异或它自己都为0，因此那些出对出现的数字都在异或中被抵消了。

之后，考虑如果能将原数组拆分成两个子数组，使得每个子数组只包含一个只出现一次的数字，而其他数字均出现两次。这样就可以按照上面的方法找到这两个只出现一次的数字了。

上述分组需满足以下两个条件
* 相同的数字分到同一组
* 两个只出现一次的数字分到不同的组

因为相同的数字异或的结果为0，因此数组中所有数字异或的结果就是那两个只出现一次的数字异或的结果。将这个结果的二进制表示中右数第一个为1的位记为n，它意味着那两个只出现一次的数组的二进制表示中，第n位的数值是不同的。因此以第n位是否为1作为分组的根据，就可以将这两个只出现一次的树分到两个不同的组里。此外，由于相同的数字任何一位都相同，因此按这个分组依据，相同的数字肯定也会分到同一个组。

因此，将题目分解为如何把原数组分成每个数组中只有一个元素出现一次的两个子数组、以及如何在这样的子数组中求出这个只出现一次的元素这两个问题。并逐一解决，此题便得以解决。

## 代码
```java
public int[] singleNumbers(int[] nums) {
    //res存储所有数字异或的结果
    int res = 0;
    for(int num : nums)
        res ^= num;
    int mask = 1;
    while((res & mask) == 0)
        mask = mask << 1;
    //经过上述循环，mask只有第n位是1，其余位是0
    int a = 0;
    int b = 0;
    //用第n位是否为1将原数组划分为两组
    //a、b分别用来保存两个组中只出现一次的元素
    for(int num : nums){
        if((num & mask) == 0)
            a ^= num;
        else
            b ^= num;
    }
    return new int[]{a, b};
}
```
**时间复杂度**：O(n)  
**空间复杂度**：O(1)

## 题目二

在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

    示例 1：
    输入：nums = [3,4,3,3]
    输出：4

    示例 2：
    输入：nums = [9,1,7,9,7,9,7]
    输出：1

## 方法
如果一个数字出现了三次，那么它的二进制表示中的每一位（0或1）也将出现3次。如果把所有出现3次的数字的二进制表示中的每一位都分别加起来，那么每一位的和都能被3整除（$0/3=0； 3/3=0$）。

我们把数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除，那么那个只出现一次的数字的二进制表示中那一位是0，否则就是1。

上述思路同样适用于数组中一个数字出现一次，其他数字出现奇数次问题(如果是偶数次，直接用异或就可)。

## 代码
```java
public int singleNumber(int[] nums) {
    if(nums.length == 0)
        return -1;
    //数组count用来存储所有数字的各二进制位的1的出现次数
    //注：java中int类型为4字节，32位。
    int[] count = new int[32];
    for(int num : nums){
        int mask = 1;
        for(int j = 31; j >= 0; j--){
            if((num & mask) != 0)
                count[j]++;
            mask = mask << 1;
        }
    }
    int res = 0;
    for(int i = 0; i < 32; i++) {
        res = res << 1;
        res += count[i] % 3;
    }
    return res;
}
```

**时间复杂度**：O(n)  
**空间复杂度**：O(1)
