# 面试题49：丑数

## 题目
我们把只含因子2，3，5的数称作丑数(Ugly Number)。求按从小到大的顺序的第 n 个丑数。此外，1也可算作丑数

## 方法1
先来判断一个数是否为丑数。因为丑数只能被2，3，5整除。也就是说，如果一个数能被2整除，就连续除以2；如果能被3整除，就连续除3；如果能被5整除，就连续除5。如果最后得到的是1，那么这个数就是丑数。
```java
//判断一个数是否是丑数
public boolean isUglyNumber(int number){
    if(number == 1)
        return true;
    while(number % 2 == 0)
        number = number / 2;
    while(number % 3 == 0)
        number = number / 3;
    while(number % 5 == 0)
        number = number / 5;
    return number == 1;
}
```
接下来，只需要按照顺序判断每个整数是否是丑数即可解决问题。
```java
//此函数返回第n个丑数
public int nthUglyNumber(int n) {
    if(n <= 0)
        return 0;
    int count = 0;
    int num = 1;
    while(count < n){
        count += isUglyNumber(num) ? 1:0;
        num++;
    }
    return num;
}
```
但是，该方法的问题在于每个整数都需要计算，即使一个数字不是丑数，还是要对它执行求余数和出发操作，因此时间效率不是很高。

## 方法2(用空间换时间)
上述方法之所以时间效率不高，是因为不管一个数是不是丑数，我们都要对它进行计算。接下来我们试着找到一种只计算丑数的方法，而不在非丑数的整数上面浪费时间。

根据丑数的定义，一个丑数应该是另一个丑数乘以2、3、5的结果，因此，我们可以创建一个数组，里面的数字是排序好的丑数，每个丑数都是前面的丑数乘以2、3或者5得到的。

假设数组中已经有若干个排序好的丑数，并且把已有的最大丑数记作M，接下来分析如何生成下一个丑数。下一个丑数肯定是前面的丑数乘2、3或者5得到的，所以首选考虑将已有的每个丑数乘以2，记录第一个乘以2后大于M的结果为M2。同样，把已有的每个丑数乘以3和5得到的第一个大于M的结果记为M3和M5，那么下一个丑数应该是M2、M3、M5这三个数中的最小值。

进一步分析，其实并不需要对每一个丑数都乘2、3、5。因为已有的丑数都是按顺序放在数组中的，对于乘以2而言，肯定存在一个丑数dp[i2]，排在它之前的每一个丑数乘以2的结果都小于当前最大的丑数，在它之后的每个丑数乘以2的结果又会太大。我们只需要记下这个丑数的位置i2，每次生成新的丑数时更新i2即可。对于乘以3和乘以5来说，也存在同样的i3和i5。

## 代码
```java
public int nthUglyNumber(int n) {
    if(n <= 0)
        return 0;
    //建立一个用于存放丑数的数组
    int[] dp = new int[n];
    //注意1也算作丑数
    dp[0] = 1;
    //指针i2,i3,i5代表其位置上的元素乘以2,3,5之后大于目前最大丑数的最小索引（需大于目前最大丑数，但又不能大太多）
    //下一个丑数只能是dp[i2],dp[i3],dp[i5]中的其中一个（最小的那个）
    int i2 = 0,i3 = 0,i5 = 0;
    for(int i = 1; i < n; i++){
        int M2 = dp[i2]*2, M3 = dp[i3]*3, M5 = dp[i5]*5;
        dp[i] = Math.min(M2, Math.min(M3,M5));
        //在生成新的丑数后，更新三个指针，使dp[i2]*2，dp[i3]*3和dp[i5]*5永远大于当前最大的丑数
        while(dp[i2] * 2 <= dp[i])
            i2++;
        while(dp[i3] * 3 <= dp[i])
            i3++;
        while(dp[i5] * 5 <= dp[i])
            i5++;
    }
    return dp[n-1];
}
```

## 测试用例
* 功能测试（2,3,4,5,6等)
* 特殊输入测试（边界值1，无效值0）
* 性能测试（较大的数字，如1500）
