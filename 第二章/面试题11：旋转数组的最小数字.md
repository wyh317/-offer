# 面试题11：旋转数组的最小数字

## 题目
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。

## 方法：
旋转之后的数组实际上可以划分为两个排序好的子数组。前面的子数组的元素都大于等于后面子数组的元素，并且最小的元素刚好是这两个数组的分界线。由于数组在一定程度上有序，所以采用二分查找的思路

先用两个指针分别指向第一个元素和最后一个元素。然后找到数组中间的元素，
*   若该中间元素大于等于第一个指针所指向的元素，则它位于前面的子数组，此数组中最小的元素应该位于该中间元素的后面。于是把第一个指针指向该中间元素以缩小范围。
*   若该中间元素小于等于第二个指针所指向的元素，则它位于后面的子数组，此数组中最小的元素应该位于该中间元素的前面。于是把第二个指针指向该中间元素以缩小范围

之后再用更新后的指针重复做新一轮的查找。
按照上述思路，第一个指针总是指向前一个子数组的元素，第二个指针总是指向后一个子数组的元素。最终第一个指针将指向前面子数组的最后一个元素，第二个指针将指向后面子数组的第一个元素。也就是说，当它们指向的元素相邻时，第二个指针指向的刚好是最小的元素，循环结束

注意：  
当两个指针指向的数字和它们中间的数字三者相同时，无法判断中间的数字属于前面的子数组还是后面的子数组，也就无法通过移动两个指针来缩小查找范围，这时不得不用顺序查找的方法。例如：数组为[1,0,1,1,1]或[1,1,1,0,1]的情况

## 代码
```java
public int minNumberInRotateArray(int [] array) {
    if(array == null || array.length == 0)
        return 0;
    int left = 0;
    int right = array.length - 1;
    int mid = 0;
    //用于处理数组本身就是一个排序数组的情况（未旋转）
    if(array[right] > array[left])
        return array[0];
    while(left + 1 < right){
        mid = left + (right - left) / 2;
        //处理两个指针和mid所指的数值相同的情况，这是只能顺序查找
        if(array[left] == array[right] && array[right]== array[mid])
            return minInOrder(array,left,right);
        if(array[mid] >= array[left])
            left = mid;
        if(array[mid] <= array[right])
            right = mid;
    }
    return array[right];
}

public int minInOrder(int[] array, int left, int right){
    int min = array[left];
    for(int i = left + 1; i <= right; i++){
        if(array[i] < min)
            min = array[i];
    }
    return min;
}
```

### 测试用例：
* 功能测试（输入的数组是升序排序数组的一个旋转，数组中有重复数字或者没有重复数字）
* 边界值测试（输入数组本身就是一个排序好的数组，只包含一个数字的数组）
* 特殊输入测试（数组为null）
