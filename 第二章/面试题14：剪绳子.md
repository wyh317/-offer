# 面试题14：剪绳子

## 题目： 
给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1，m<=n），每段绳子的长度记为k[1],...,k[m]。请问k[1]  x... x k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

## 方法1（动态规划）

典型的动态规划求解问题：每一步都有若干个选择。
在本题中，剪第一刀的时候有n-1个可能的选择，即可以剪在长度为1、2、...n-1的任意位置。由于事先不知道剪在哪个位置是最优的选择，只能把每种可能都尝试一遍，然后得到最优的剪法。

定义函数f(n)为把长度为n的绳子剪成若干段后各段长度的最大值。于是有递归公式：
$f(n) = f(i) * f(n - i)$  其中0<i<n

以上我们从上往下分析了这个问题，接下来从下往上求解这个问题，也就是说我们先得到f(2),f(3),再得到f(4)，f(5)，再得到f(n)

## 代码
```java
public int cutRope(int length) {
    if(length <= 1)
        return 0;
    if(length == 2)
        return 1;
    if(length == 3)
        return 2;
    //products数组用于存放对长度为i的绳子进行裁剪后的各部分乘积最大值
    int[] dp = new int[length + 1];
    //由于以上三个if语句已经把length小于等于3的情况处理好了。进行到此时，说明length大于3。
    //所以以下几个不是乘积最大值。可以理解为，对长度为1、2、3的绳子片段不裁剪时其长度
    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 3;
    //对每一个dp[i]都需要遍历各个j时的取值，找到最大值后，赋给dp[i]
    for(int i = 4; i <= length; i++){
        int max = 0;
        for(int j = 1; j <= i/2; j++){
            int res = dp[j] * dp[i - j];
            if(res > max)
                max = res;
        }
        dp[i] = max;
    }
    return dp[length];
}
```
时间复杂度：$O(n^2)$  
空间复杂度：$O(n)$

## 方法2（贪心算法）

绳子长度n为2、3时，最长长度为1、2，很容易理解。进一步考虑，当绳子长度为4时，最长长度为2*2=4。当绳子长度n大于等于5时，考虑满足i * (n- i) > n的i值为2，3。意思为：当长度大于5时，将绳子剪为长度为2或长度为3的绳子段产生的最大乘积大于压根不剪这段绳子的情况。并且3(n-3) >  2(n-2)。

因此，解决问题的贪心策略为：
* 当n>=5时，尽可能多地剪长度为3的绳子
* 当剩下的绳子n=4时，把绳子剪成两段长度为2的绳子

## 代码
```java
public int cutRope(int n) {
    if (n < 2)
        return 0;
    if (n == 2)
        return 1;
    if (n == 3)
        return 2;
    //尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。
    //如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合成长度为4的绳子，把它们切成两段长度为 2 的绳子。
    int timesOf3 = n / 3;
    if (n - timesOf3 * 3 == 1)
        timesOf3--;
    int timesOf2 = (n - timesOf3 * 3) / 2;
    return (int) (Math.pow(3, timesOf3)) * (int) (Math.pow(2, timesOf2));
}
```

时间复杂度:O(1)  
空间复杂度:O(1)
